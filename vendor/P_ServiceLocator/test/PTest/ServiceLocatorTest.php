<?php
namespace PTest;

use P\ServiceLocator;

/**
 * Generated by PHPUnit_SkeletonGenerator on 2012-08-18 at 10:39:34.
 */
class ServiceLocatorTest extends \PHPUnit_Framework_TestCase
{
    /**
     * @var ServiceLocator
     */
    protected $serviceLocator;

    /**
     * Sets up the fixture, for example, opens a network connection.
     * This method is called before a test is executed.
     */
    protected function setUp()
    {
        $this->serviceLocator = new ServiceLocator;
    }

    /**
     * Tears down the fixture, for example, closes a network connection.
     * This method is called after a test is executed.
     */
    protected function tearDown()
    {
    }

    /**
     * @covers P\ServiceLocator::has
     */
    public function testHas()
    {
        $this->assertFalse($this->serviceLocator->has('foo'));
        $this->serviceLocator->set('foo', array());
        $this->assertTrue($this->serviceLocator->has('foo'));

        $this->serviceLocator->set('Boo-Boo', array());
        $this->assertTrue($this->serviceLocator->has('boo_boo'));
    }

    /**
     * @covers P\ServiceLocator::set
     */
    public function testSet()
    {
        $this->assertSame($this->serviceLocator, $this->serviceLocator->set('foo', array()));
    }

    /**
     * @covers P\ServiceLocator::set
     */
    public function testSetThrowsExceptionOnInvalidServiceName()
    {
        $this->setExpectedException('InvalidArgumentException', '$name must be a string in ServiceLocator::set()');
        $this->serviceLocator->set(5, array());
    }

    /**
     * @covers P\ServiceLocator::set
     */
    public function testSetThrowsExceptionOnInvalidService()
    {
        $this->setExpectedException('InvalidArgumentException', '$service must be an array, object or callable in ServiceLocator::set()');
        $this->serviceLocator->set('foo', 5);
    }

    /**
     * @covers P\ServiceLocator::set
     */
    public function testSetThrowsExceptionWhenTryingToSetUnmodifiableService()
    {
        $this->serviceLocator->set('foo', array());
        $this->setExpectedException('InvalidArgumentException', 'This service foo is already set and not modifiable.');
        $this->serviceLocator->set('foo', array());
    }

    /**
     * @covers P\ServiceLocator::set
     */
    public function testSetThrowsExceptionWhenTryingToSetInitializerForUnregisteredService()
    {
        $this->setExpectedException('InvalidArgumentException', 'An initializer cannot be set for a service that does not exist.');
        $this->serviceLocator->set('foo+', array());
    }

    /**
     * @covers P\ServiceLocator::get
     */
    public function testGet()
    {
        $this->serviceLocator->set('foo', function () { return new \stdClass(); });
        $this->assertInstanceOf('stdClass', $this->serviceLocator->get('foo'));
    }

    /**
     * @covers P\ServiceLocator::remove
     */
    public function testRemove()
    {
        $this->serviceLocator->set('foo', array(), true);
        $this->assertTrue($this->serviceLocator->has('foo'));
        $this->assertSame($this->serviceLocator, $this->serviceLocator->remove('foo'));
        $this->assertFalse($this->serviceLocator->has('foo'));
    }

    /**
     * @covers P\ServiceLocator::remove
     */
    public function testRemoveThrowsExceptionOnInvalidServiceName()
    {
        $this->setExpectedException('InvalidArgumentException', 'foo is not a registered service.');
        $this->serviceLocator->remove('foo');
    }

    /**
     * @covers P\ServiceLocator::remove
     */
    public function testRemoveThrowsExceptionOnRemovalOfUnmodifiableService()
    {
        $this->serviceLocator->set('foo', array());
        $this->setExpectedException('InvalidArgumentException', 'This service foo is marked as unmodifiable and therefore cannot be removed');
        $this->serviceLocator->remove('foo');
    }

    /**
     * @covers P\ServiceLocator::offsetSet
     */
    public function testOffsetSet()
    {
        $this->serviceLocator['foo'] = function () { return new \stdClass(); };
        $this->assertTrue($this->serviceLocator->has('foo'));
    }

    /**
     * @covers P\ServiceLocator::offsetGet
     */
    public function testOffsetGet()
    {
        $this->serviceLocator->set('foo', function () { return new \stdClass(); });
        $this->assertInstanceOf('stdClass', $this->serviceLocator->offsetGet('foo'));
        $this->assertInstanceOf('stdClass', $this->serviceLocator['foo']);
    }

    /**
     * @covers P\ServiceLocator::offsetExists
     */
    public function testOffsetExists()
    {
        $this->serviceLocator->set('foo', function () { return new \stdClass(); });
        $this->assertTrue($this->serviceLocator->offsetExists('foo'));
        $this->assertTrue(isset($this->serviceLocator['foo']));
    }

    /**
     * @covers P\ServiceLocator::offsetUnset
     */
    public function testOffsetUnset()
    {
        $this->serviceLocator->set('foo', function () { return new \stdClass(); }, true);
        $this->assertTrue($this->serviceLocator->has('foo'));
        unset($this->serviceLocator['foo']);
        $this->assertFalse($this->serviceLocator->has('foo'));
    }

    /**
     * @covers P\ServiceLocator::count
     */
    public function testCount()
    {
        $this->assertEquals(0, $this->serviceLocator->count());
        $this->serviceLocator->set('foo', function () { return new \stdClass(); }, true);
        $this->serviceLocator->set('boo', function () { return new \stdClass(); }, true);
        $this->assertEquals(2, $this->serviceLocator->count());
    }
}
